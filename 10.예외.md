# 예외
## 아이템 69. 예외는 진짜 예외 상황에만 사용하라
예외는 오직 예외 상황에서만 써야한다. 일상적인 제어 흐름을 위해 예외를 사용했다가 버그와 혼란만 가중시킨다. 다음은 반복문을 종료시키기 위한 흐름 제어용 예외이다. 
```java
        try{
            int i=0;
            while(true){
                range[i++].climb();
            }
        }catch (ArrayIndexOutOfBoundsException e){
            
        }
        
```
이러한 코드는 크게 두 가지 문제점이 있다. 먼저 JVM이 적용할 수 있는 최적화가 제한된다. 코드를 try-catch문에 넣었기 때문이다. 따라서 흐름 제어용 예외는 프로그램의 성능을 떨어뜨린다. 또한 진짜 버그를 숨긴다. 반목문을 수행하며 잘못된 요소에 접근하여 진짜 ArrayIndexOutBoundsException이 발생했을 경우 프로그램은 정상적으로 흐른다. 표준적인 for문을 사용했더라면 예외가 발생하고 스택 추적 정보들이 남겨진 채, 해당 쓰레드는 종료될 것이다. 즉, 표준 for문을 통해서는 오류의 원인을 정확히 찾을 수 있다. 반면, 흐름 제어용 예외의 경우 진짜 예외가 발생했는데, 프로그램이 정상적으로 흐르기에 코드의 버그를 찾기 어렵다.  
정리하자면, 예외는 예외 상황에서 사용하는 것이 프로그램의 성능 및 버거깅 측면에서 바람직하다.  

## 아이템 70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라
자바는 문제 상황을 알리는 타입으로 Throwable을 Exception과 Error를 제공한다. Error가 발생하면 프로그램 코드에 의해 수습될 수 없으며 프로그램이 종료된다. Error의 대표적인 예로는 OutOfMemomryError, StackOverFlowError가 있다.  
한편, Exception은 프로그램 코드에 의해 수습될 수도 있는 문제로 다시 Unchecked 예외와 Checked 예외로 나뉜다. Unchecked 예외의 대표적인 예로는 NullPointerException, ArrayIndexOutOfBoundsException와 같은 RuntimeException이 있다. Checked 예외의 대표적인 예로는 IOException, SQLException이 있다.   
Unchecked 예외와 Checked예외를 사용해야 하는 기준은 복구할 수 있느냐에 따라 달렸다. 호출하는 쪽에서 복구하리라 여겨지는 상황에서는 Checked 예외를 사용해야한다. 복구하리라 여겨지는 상황에서 더 나아가, Checked 예외는 호출하는 쪽에서 복구해달라는 요구를 할 수 있다. 반면, Unchecked 예외는 클라이언트가 복구할 수 없고 그럴 필요가 없는 상황에서 사용해야 한다. 주로 프로그래밍 오류가 될 수 있는데, 대부분이 특정 전제 조건을 만족하지 못해서 발생한다. 예를 들어, 여러 사이트에서 널리 사용되는 유효성 검증 실패 시 발생하는 예외가 있다. 해당 예외는 특정 조건을 만족하지 못했기에 클라이언트가 이를 잡아서 해결할 방안이 없다. 이런 예외를 잡지 않은 스레드는 적절한 오류 메시지를 내뱉으며 중단된다.  
정리하자면, 복구할 수 있는 상황 또는 호출하는 쪽에서 복구해야하는 상황이면 Checked 예외를, 프로그래밍 오류라는 UnChecked 예외를 던지는 것이 바람직하다.

## 아이템 71. 필요 없는 검사 예외 사용은 피하라
checekd 예외를 적절히 사용하면, 프로그램의 안정성을 높일 수 있다. 클라이언트 코드에서 예외를 잡아 문제를 처리하기 때문이다. 하지만 checekd 예외를 과도하게 사용하면, 불편한 API를 생상하게 된다. API를 호출하는 쪽에서는, catch 블록에서 예외를 처리하거나, 더 바깥으로 던져 문제를 전파해야한다. 누가 예외를 처리하든지 호출하는 쪽에서는 예외 처리에 대한 짐이 있는 것이다. 또한 검사 예외를 던지는 메서드는 스트림 안에서 사용할 수 없기에 자바8에서는 검사 예외 사용에 대한 부담이 있다. 따라서 의미있는 예외이며 클라이언트 쪽에서 꼭 처리해야하는 예외가 아니라면 unchecked 예외를 사용하는 것이 좋다.

## 아이템 72. 표준 예외를 사용하라
숙련된 프로그래머는 코드를 재사용하는 데 능숙하다. 표준 예외를 재사용면 얻는 이점이 많다. 표준 예외를 재사용한 API의 경우 다른 개발자들이 익히기 더 쉽다는 이점이 있다. 많은 개발자들이 익숙한 규약을 그대로 따른 API이기 때문이다. 
한편, Exception, RuntimeException, Throwable, Error는 직접 재사용하지 않는 것이 관례이다. 여러 성격의 예외를 포괄하는 추상적인 예외 계층이기 때문이다. null 값을 허용하지 않는 곳에 null이 들어온 경우, RuntimeException을 던지는 것보다 NullPointerException을 던지는 편이 어떤 예외인지를 더 명확히 알려준다.

## 아이템74. 추상화 수준에 맞는 예외를 던저라
상위 계층의 메서드 수행 시, 하위 계층의 구체적인 예외가 발생하면 관련없는 현재 메서드의 일과는 관련없는 예외처럼 보일 수 있다. 또한 하위 계층의 구체적인 예외를 상위계층으로 노출시키면 의존성이 강화된다. 이러한 문제를 해결하기 위해선, 상위 계층에서 저수준의 예외를 잡아 자신의 추상화 수준에 맞는 에외를 던저야한다. 이를 '예외 번역'이라고 한다. 
```java
try{

}catch(LowerLevelException e){
    throw new HigherLevelException(e)
}
```
예외 번역 시, 저수준 예외를 생성자의 매개변수로 보내는 것이 바람직하다. 이렇게 하면, 고수준의 예외를 던지면서도 근본 원인도 함께 알려주어 오류를 분석하기 용이하기 때문이다.  

## 아이템75. 메서드가 던지는 모든 예외를 문서화하라
메서드가 던지는 모든 예외를 자바독의 @throws 태그를 사용하여 문서화하는 것이 바람직하다. 이는 메서드를 올바르게 사용할 수 있는 중요한 정보를 제공하기 때문이다. 만약 예외를 문서로 남기지 않는다면, 발생할 수 있는 예외를 고려하여 코드를 짤 수 없기 때문에 효과적인 클래스 또는 인터페이스 사용이 어려워질 수 있다. 따라서 올바른 API 사용을 위해서라면 가능한 모든 예외에 대해 문서화하는 것이 바람직하다.