# 예외
## 아이템 69. 예외는 진짜 예외 상황에만 사용하라
예외는 오직 예외 상황에서만 써야한다. 일상적인 제어 흐름을 위해 예외를 사용했다가 버그와 혼란만 가중시킨다. 다음은 반복문을 종료시키기 위한 흐름 제어용 예외이다. 
```java
        try{
            int i=0;
            while(true){
                range[i++].climb();
            }
        }catch (ArrayIndexOutOfBoundsException e){
            
        }
        
```
이러한 코드는 크게 두 가지 문제점이 있다. 먼저 JVM이 적용할 수 있는 최적화가 제한된다. 코드를 try-catch문에 넣었기 때문이다. 따라서 흐름 제어용 예외는 프로그램의 성능을 떨어뜨린다. 또한 진짜 버그를 숨긴다. 반목문을 수행하며 잘못된 요소에 접근하여 진짜 ArrayIndexOutBoundsException이 발생했을 경우 프로그램은 정상적으로 흐른다. 표준적인 for문을 사용했더라면 예외가 발생하고 스택 추적 정보들이 남겨진 채, 해당 쓰레드는 종료될 것이다. 즉, 표준 for문을 통해서는 오류의 원인을 정확히 찾을 수 있다. 반면, 흐름 제어용 예외의 경우 진짜 예외가 발생했는데, 프로그램이 정상적으로 흐르기에 코드의 버그를 찾기 어렵다.  
정리하자면, 예외는 예외 상황에서 사용하는 것이 프로그램의 성능 및 버거깅 측면에서 바람직하다.  

## 아이템 70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라
자바는 문제 상황을 알리는 타입으로 Throwable을 Exception과 Error를 제공한다. Error가 발생하면 프로그램 코드에 의해 수습될 수 없으며 프로그램이 종료된다. Error의 대표적인 예로는 OutOfMemomryError, StackOverFlowError가 있다.  
한편, Exception은 프로그램 코드에 의해 수습될 수도 있는 문제로 다시 Unchecked 예외와 Checked 예외로 나뉜다. Unchecked 예외의 대표적인 예로는 NullPointerException, ArrayIndexOutOfBoundsException와 같은 RuntimeException이 있다. Checked 예외의 대표적인 예로는 IOException, SQLException이 있다.   
Unchecked 예외와 Checked예외를 사용해야 하는 기준은 복구할 수 있느냐에 따라 달렸다. 호출하는 쪽에서 복구하리라 여겨지는 상황에서는 Checked 예외를 사용해야한다. 복구하리라 여겨지는 상황에서 더 나아가, Checked 예외는 호출하는 쪽에서 복구해달라는 요구를 할 수 있다. 반면, Unchecked 예외는 클라이언트가 복구할 수 없고 그럴 필요가 없는 상황에서 사용해야 한다. 주로 프로그래밍 오류가 될 수 있는데, 대부분이 특정 전제 조건을 만족하지 못해서 발생한다. 예를 들어, 여러 사이트에서 널리 사용되는 유효성 검증 실패 시 발생하는 예외가 있다. 해당 예외는 특정 조건을 만족하지 못했기에 클라이언트가 이를 잡아서 해결할 방안이 없다. 이런 예외를 잡지 않은 스레드는 적절한 오류 메시지를 내뱉으며 중단된다.  
정리하자면, 복구할 수 있는 상황 또는 호출하는 쪽에서 복구해야하는 상황이면 Checked 예외를, 프로그래밍 오류라는 UnChecked 예외를 던지는 것이 바람직하다.

## 아이템 71. 필요 없는 검사 예외 사용은 피하라
checekd 예외를 적절히 사용하면, 프로그램의 안정성을 높일 수 있다. 클라이언트 코드에서 예외를 잡아 문제를 처리하기 때문이다. 하지만 checekd 예외를 과도하게 사용하면, 불편한 API를 생상하게 된다. API를 호출하는 쪽에서는, catch 블록에서 예외를 처리하거나, 더 바깥으로 던져 문제를 전파해야한다. 누가 예외를 처리하든지 호출하는 쪽에서는 예외 처리에 대한 짐이 있는 것이다. 또한 검사 예외를 던지는 메서드는 스트림 안에서 사용할 수 없기에 자바8에서는 검사 예외 사용에 대한 부담이 있다. 따라서 의미있는 예외이며 클라이언트 쪽에서 꼭 처리해야하는 예외가 아니라면 unchecked 예외를 사용하는 것이 좋다.

## 아이템 72. 표준 예외를 사용하라
숙련된 프로그래머는 코드를 재사용하는 데 능숙하다. 표준 예외를 재사용면 얻는 이점이 많다. 표준 예외를 재사용한 API의 경우 다른 개발자들이 익히기 더 쉽다는 이점이 있다. 많은 개발자들이 익숙한 규약을 그대로 따른 API이기 때문이다. 
한편, Exception, RuntimeException, Throwable, Error는 직접 재사용하지 않는 것이 관례이다. 여러 성격의 예외를 포괄하는 추상적인 예외 계층이기 때문이다. null 값을 허용하지 않는 곳에 null이 들어온 경우, RuntimeException을 던지는 것보다 NullPointerException을 던지는 편이 어떤 예외인지를 더 명확히 알려준다.

## 아이템74. 추상화 수준에 맞는 예외를 던저라
상위 계층의 메서드 수행 시, 하위 계층의 구체적인 예외가 발생하면 관련없는 현재 메서드의 일과는 관련없는 예외처럼 보일 수 있다. 또한 하위 계층의 구체적인 예외를 상위계층으로 노출시키면 의존성이 강화된다. 이러한 문제를 해결하기 위해선, 상위 계층에서 저수준의 예외를 잡아 자신의 추상화 수준에 맞는 에외를 던저야한다. 이를 '예외 번역'이라고 한다. 
```java
try{

}catch(LowerLevelException e){
    throw new HigherLevelException(e)
}
```
예외 번역 시, 저수준 예외를 생성자의 매개변수로 보내는 것이 바람직하다. 이렇게 하면, 고수준의 예외를 던지면서도 근본 원인도 함께 알려주어 오류를 분석하기 용이하기 때문이다.  

## 아이템75. 메서드가 던지는 모든 예외를 문서화하라
메서드가 던지는 모든 예외를 자바독의 @throws 태그를 사용하여 문서화하는 것이 바람직하다. 이는 메서드를 올바르게 사용할 수 있는 중요한 정보를 제공하기 때문이다. 만약 예외를 문서로 남기지 않는다면, 발생할 수 있는 예외를 고려하여 코드를 짤 수 없기 때문에 효과적인 클래스 또는 인터페이스 사용이 어려워질 수 있다. 따라서 올바른 API 사용을 위해서라면 가능한 모든 예외에 대해 문서화하는 것이 바람직하다.

## 아이템76. 가능한 실패 원자적으로 만들라
실패 원자적 메서드란 호출 시 예외가 발생했다고 하더라도 호출 전과의 객체 상태의 동일성을 보장하는 메서드를 뜻한다. 실패 원자적 메서드는 여러 면에서 유용하다. 먼저 호출자는 실패와 관련된 상태 복구에 대한 부담이 줄어든다. 또한 디버깅에도 유용하다. 실패한 메서드가 객체의 상태를 바꾼 채로 남겨두면, 어떤 상태에서 예외가 발생했는 지 예측하기 어려워진다.  
아래 Stack 클래스의 pop 메서드는 실패 원자적이라 할 수 있다. Stack 인스턴스의 size가 0이어서 예외가 발생한다 하더라도 맴버변수들은 호출 전의 상태를 유지하고 있기 때문이다. 즉, 예외가 발생하더라도 상태가 바뀌지 않는다.  
```java
public Object pop(){
    if(size == 0){
        throw new EmptyStackException();
    }

    Object result = elements[--size];
    element[size] = null;
    return result;
}
```
메서드를 실패 원자적으로 만드는 대표적인 방법으로는 3가지가 있다.  
첫 번째, 객체를 불변객체로 설계하는 것이다. 불변 객체란 인스턴스 내부 값을 수정할 수 없는 객체이다. 값을 바꿀 수 없기에 메서드 수행 중 예외가 발생하더라도 상태 값은 유지된다.  
두 번째, 작업 수행 전, 유효성을 검사하는 것이다. 즉, 객체의 상태를 변경하는 잠재적 예외 발생 코드 수행 전 유효성 검사를 하는 것이다. 위의 pop 메서드는 Stack 인스턴스의 size을 차감하는 로직 수행 전, size의 유효성 검사를 한다. elements[--size]이 실행될 때, ArrayIndexOutOfException 예외가 발생할 가능성이 있기 때문이다. 이렇게 유효성 검사를 하면 pop 메서드를 호출하여 예외가 발생해도 메서드 호출 전과의 size 상태는 동일하다.  
마지막으로, 객체의 임시 복사본에서 로직을 수행한 후, 성공적으로 완료되면 원래 객체와 교체하는 것이다.  

## 아이템 77. 예외를 무시하지 말라
try - catch문을 사용해 예외를 잡고 catch 문에서 아무것도 하지 않는 것은 예외를 무시하는 것이다. 예외를 잡고 아무 일도 하지 않으면 오류를 내재한 체 동작할 가능성이 크다. 만약 예외를 무시할 만한 이유가 있는 경우라면 그럴만한 이유를 주석으로 남기고 예외 변수의 이름도 ignored라고 명명짓는 것이 좋다. 그렇지 않다면, 예외를 적절히 처리하거나 전파하거나 둘 중 하나를 해야한다.