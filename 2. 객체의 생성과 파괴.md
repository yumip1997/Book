# 객체의 생성과 파괴
## 아이템 1 생성자 대신 정적 팩터리 메서드를 고려하라.
정적 팩터리 메서드는 객체를 생성하여 이를 반환하는 역할을 하는 메서드이다. 클라이언트가 인스턴스를 얻는 전통적인 방법은 public 생성자이다. 하지만 정적 팩터리 메서드를 통해서도 인스턴스를 얻을 수 있고, public 생성자가 지닐 수 없는 여러 장점들이 있다.  
### 정적 팩터리 메서드는 이름을 가질 수 있다.
정적 팩터리 메서드는 이름을 가지며 이는 클라이언트에게 반환될 객체에 대한 정보를 제공한다. 예를 들어, BigInteger의 정적 팩토리 메서드 중 probablePrime이 있다. 이 메서드의 이름은 값이 소수인 BigInteger를 반환한다는 의미를 담고 있다.
### 호출될때마다 인스턴스를 새로 만들지 않아도 된다.  
public 생성자의 경우 호출될때마다 객체가 새로 생성된다. 하지만 정적 팩터리 메서드의 경우 이미 만들어진 유일한 인스턴스만을 반환할 수 있다. 객체의 생성 비용이 크다면 정적 팩터리 메서드를 이용해 프로그램의 성능을 크게 향상시킬 수 있다. 예를 들어, Boolean의 클래스 변수로 TRUE, FALSE가 있다. 정적 팩토리 메서드 valueOf는 TRUE 또는 FALSE가 가리키는 인스턴스를 반환한다. 즉, 호출될때마다 새롭게 객체를 생성하지 않는 것이다. 
```java
    public static final Boolean TRUE = new Boolean(true);
    public static final Boolean FALSE = new Boolean(false);

    public static Boolean valueOf(boolean b) {
        return (b ? TRUE : FALSE);
    }
``` 
  
### 정적 팩토리 메서드는 반환하는 타입의 하위 타입의 객체를 반환할 수 있다. 
```java
    public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType) {
        Enum<?>[] universe = getUniverse(elementType);
        if (universe == null)
            throw new ClassCastException(elementType + " not an enum");

        if (universe.length <= 64)
            return new RegularEnumSet<>(elementType, universe);
        else
            return new JumboEnumSet<>(elementType, universe);
    }
```
noneOf 정적 팩토리 메서드는 원소가 64개 이하이면 EnumSet<E>의 하위 타입인 RegulartEnumSet을 그렇지 않으면 JumboEnumSet을 반환한다. 해당 메서드를 사용하는 클라이언트는 경우에 따라 어떤 하위 타입이 반환되는지 모른다. 즉, 추상 타입으로만 메서드를 다루는 것이다. 이는 API의 유연성을 극대활시킬 수 있는 방식이다. 만약 경우의 수를 변경하여 반환하는 객체를 추가하거나 줄여도 클라이언트에게는 아무런 영향이 없다. 클레이언트는 구체 타입이 아닌 추상 타입으로 해당 메서드를 사용하고 있기 때문이다. 더 나아가, 반환하는 타입의 하위 타입의 객체를 반환하는 능력은 API를 작게 유지할 수 있으며 개발자가 익혀야 하는 개념의 수를 줄일 수 있다. 만약 noneOf라는 메서드 없이 RegularEnumSet, JumboEnumSet를 반환하는 메서드가 각각 있었다면 API 명세는 늘어났을 것이다. 그리고 개발자가 익혀야하는 API의 수도 많아졌을 것이다.  
정리하자면, 반환하는 타입의 하위 타입의 객체를 반환할 수 있는 정적 팩토리 메서드는 클라이언트가 메서드를 추상적으로 다룰 수 있도록 하여 메서드의 유연성을 높인다. 또한 API를 작게 유지하고 개발자가 알아야할 개념도 줄여주는 장점을 지니고 있다.  

정적 팩토리 메서드를 사용하면 위와 같은 장점이 있다. 하지만 클래스에 정적 팩토리 메서드는 생성자와는 다르게 자바 문법은 아니다. 따라서 정적 팩토리 메서드를 이용해 객체를 얻고 싶다면 해당 메서드에 대한 명세를 알아야한다. 즉, 개발자가 명세를 보지 않으면 모르고 지나칠 수도 있다는 것이다.  

다음은 정적 팩토리 메서드에 대한 명명 관습이다.
- form
  - 매개변수를 하나 받아 해당 타입의 객체를 반환한다.
  ```java
  Date date = Data.from(instant)
  ```
- of
  - 매개변수를 여러개 받아 해당 타입의 객체를 반환한다.
  ```java
  Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);
  ```
- valueOf
  - 매개변수를 받아 해당 타입의 객체를 반환한다.
  ```java
  BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE)
  ```
- instance 또는 getInstance
  - 매개변수를 받는다면 매개변수와 관련한 객체를 반환한다.
  ```java
  MessageDigest digest = MessageDigest.getInstance(ALGORITHM_SHA_512)
  ```
- create 또는 newInstance
  - 매번 새로운 인스턴스를 생성해 반환함을 보장한다.
  ```java
  Object newArray = Array.newInstance(classObject, arrayLen)
  ```
- get[Type]
  - Type에 해당하는 타입의 인스턴스를 반환한다. 따라서 해당 메서드를 호출하는 객체의 타입과는 다를 수 있다.
  ```java
  FileStore fileStore = Files.getFileStore(path)
  ```
- new[Type]
  - Type에 해당하는 타입의 인스턴스를 매번 생성하여 반환함을 보장한다.
  ```java
  BufferedReader bufferedReader = Files.newBufferedReader(path)
  ```
- [type]
  - get[Type], new[Tpye]의 간결한 버전이다.
  ```java
  List<String> strList = Arrays.asList("effective", "java")
  ```


## 아이템2. 생성자에 매개변수가 많다면 빌더를 고려하라
## 아이템3. private 생성자나 열거 타입으로 싱글턴임을 보증하라
싱글턴이란 인스턴스를 단 하나만 생성할 수 있는 클래스를 의미한다. 싱글턴을 만드는 방법으로 크게 3가지가 있다.  
첫 번째, public static final 필드를 사용하는 것이다. 생성자의 접근제한자를 private으로 해두고, public static final 필드가 생성자를 이용해 생성한 인스턴스를 참조하도록 하는 것이다.
```java
public class DataCreator {
  public static final DataCreator INSTANCE = new DataCreator();
  private DataCreator() {}
}
```
두 번째, public static 메서드를 이용하는 방법이다. 생성자의 접근제한자를 private으로 정의하고, private static final 필드가 생성자를 이용하여 생성된 객체를 가리키도록 한다. 그리고 public static 메서드가 해당 필드가 가리키는 객체를 반환하도록 하는 것이다.
```java
public class DataCreator {
  private static final DataCreator INSTANCE = new DataCreator();
  private DataCreator() {}

  public static DataCreator getInstance(){
    return INSTANCE;
  }
}
```
마지막으로, 원소가 하나인 열거타입을 선언하는 것이다. 부자연스러울 수 있으나, 해당 열거타입의 인스턴스가 단 하나임이 보장된다. 하지만 열거타입이 상속해야할 클래스가 있다면 부적절하다. 열거타입은 다른 클래스를 상속받을 수 없기 때문이다.
```java
public enum DataCreator {
  INSTANCE;
}
```
## 아이템4. 인스턴스화를 막으려거든 private 생성자를 사용하라
정적 필드, 정적 메서드만으로 이루어진 클래스가 있다. 보통 유틸리티 클래스이다. 이 클래스는 상속을 위해 설계되지 않았다. 클라이언트가 필요에 따라 공개된 필드 또는 메서드를 인스턴스의 생성 없이 사용하는 클래스이다. 불필요한 인스턴스의 생성을 막기 위해선 생성자에 private 접근 제한자를 정의하면 된다. 

## 아이템5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
사용하는 자원에 따라 동작이 달라지는 클래스는 의존 객체 주입 패턴에 따라 설계하는 것이 적합하다. 의존 객체 주입 패턴은 인스턴스 생성 시, 생성자에 사용하는 객체를 넘겨주는 방식이다. 의존 객체 주입 패턴은 클래스의 유연성을 높여준다. 클라이언트가 상황에 맞게 객체를 주입해주면 유연하게 인스턴스를 사용할 수 있기 때문이다. 예를 들어, 맞춤범 검사기는 사전에 의존적인 클래스이다. 사전의 종류에는 일반 사전, 특수 어휘 사전, 테스트 사전 등이 있다. 의존 객체 주입 패턴에 따라 주입받을 객체를 가리키는 필드를 선언하고, 매개변수가 있는 생성자로 해당 필드를 초기화해주는 방식으로 구현할 수 있다. 이렇게 하면,
클라이언트가 원하는 종류의 사전을 맞춤범 검사기 생성자에 주입해주면 유연하게 맞춤범 검사 로직을 수행할 수 있을 것이다.
```java
    public class SpellChecker {
        private final Dictionary dictionary;
        
        public SpellChecker(Dictionary dictionary){
            this.dictionary = dictionary;
        }
        
        public boolean isValid(String word){
            ...
        }
    }


    //클라이언트는 상황에 맞는 사전 객체를 주입해 SpellChecker를 이용하면 된다.
    SpellChecker basicDictionary = new SpellChecker(basicDictionary);
    SpellChecker testDictionary = new SpellChecker(testDictionary);
```

## 아이템6. 불필요한 객체 생성을 피하라
프로그래밍을 하다보면 불필요하게 객체를 생성하여 메모리를 낭비하는 경우가 종종 발생한다. 크게 두 가지 상황으로 나눌 수 있다.  
첫째, 특정 객체가 재사용이 가능한데 계속 새로운 객체를 생성되는 상황이다. 예를 들어, new 연산자로 String을 사용하는 경우가 있다. 같은 문자열임에도 new 연산자가 수행될 때마다 Heap 영역에 새로운 객체가 매번 생성된다. 문자열은 재사용할 수 있는데도 새로운 문자열 객체가 매번 생성되기에 피해야할 방식이다. 기본적으로 String 리터럴을 사용해야한다. String 리터럴의 경우 Heap 영역의 String Pool에 생성되는데 String Pool에 참조하고자 하는 문자열이 있다면 해당 주소값이 참조된다. 즉, 같은 문자열이 이미 존재한다면 새로운 문자열이 재성성되지 않는 다는 것이다.  
두번째, 기본형으로 특정 로직을 수행할 수 있는 상황에서 오토박싱이 적용되는 경우이다.
해당 메서드 수행 시, 불필요한 Long 인스턴스가 2의 31제곱 만큼 만들어 진다.  
```java
private long sum(){
  Long sum = 0L;
  for(long i=0;i<=Integer.MAX_VALUE;i++){
    sum += i;
  }
  return sum;
}
```
한편, 객체를 재사용하면 위험한 상황에서는 복사본 객체를 만드는 편이 좋다. 객체를 재사용하다 객체의 요소들이 변경된다면 예상치 못한 결과가 발생할 수 있으며 이러한 버그는 찾기 힘들기 때문이다. 