## 아이템 15. 클래스와 멤버의 접근 권한을 최소화하라.
잘 설계된 컴퍼넌트는 모든 내부 구현을 완벽히 숨겨 구현과 API를 깔끔하게 분리한다. 다시 말해, 잘 설계된 컴퍼넌트는 캡슐화가 되어있다는 것이다. 접근 제한자를 제대로 사용하는 것이 캡슐화의 기본이다. 클래스의 메서드 같은 경우 API가 아니면 private 또는 package-private으로 선언하는 것이 바람직하다. public 클래스는 상수용 public static final 필드 외 public 필드를 선언하는 것은 바람직하지 않다. public 클래스의 public 필드는 클라이언트 측에서 변경가능하기에 값 또는 참조객체가 바뀌어 버리는 아주 좋지 않은 결과가 발생할 수 있기 때문이다. 참조변수를 public static final로 선언했다면 해당 참조변수가 가리키는 객체가 불변인지 확인해야 한다. 배열을 public static final로 선언했다 해도, 배열의 요소들은 변경될 수 있기 때문이다. 

## 아이템 18. 상속보다는 컴포지션을 사용하라.
클래스가 다른 클래스를 상속하는 '구현상속'의 경우, 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다. (정리 중)

## 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라.
상속용 클래스를 설계했다면, 재정의 메서드들이 내부적으로 어떻게 사용되는지를 문서로 남겨야한다. 그렇지 않다면, 재정의 메서드의 파급효과를 간과한 채 하위 클래스가 개발될 수 있기 때문이다. 해당 파급효과는 상속용 클래스에서 재정의 메서드를 내부에서 사용하는 또 다른 메서드에서 일어난다. 예를 들어, AbstractCollection의 remove 메서드는 추상메서드 iterator를 사용한다. 즉, 재정의 메서드를 사용하는 것이다. 만약, AbstractCollection을 상속받은 하위 클래스가 remove 메서드의 기능을 간과하고 iterator를 재정의 했다면, remove의 기능은 제대로 동작하지 않을 가능성이 있다. 이를 방지하기 위해선, 문서화가 필요하다. 문서화 이외의 상속용 클래스 설계 시, 중요한 제약사항이 있다. 상속용 클래스의 생정자는 재정의 메서드를 호출해서는 안된다. 상위 클래스의 생성자는 하위 클래스의 생성자보다 먼저 호출되기 때문이다. 상위 클래스의 생성자에 재정의 메서드가 포함된다면, 하위 클래스의 생성자보다 재정의 메서드가 먼저 호출되는 것이다. 하위 클래스 생성자에서 인스턴스 변수를 초기화하고 재정의 메서드가 이를 이용한다면 의도치 않은 결과가 일어날 수 있다. 
```java
    class Super {
        public Super(){
            this.overrideMe();
        }

        public void overrideMe(){

        }
    }

    class Sub extends Super{
        private final Instant instant;

        public Sub(){
            instant = Instant.now();
        }

        @Override
        public void overrideMe() {
            System.out.println(instant);
        }
    }

    public static void main(String[] args) {
        Sub sub = new Sub();
        sub.overrideMe();
    }
```

new Sub() 명령어 실행 시, 먼저 Super의 생성자가 호출되고, ovverideMe가 호출된다. 아직 Sub의 생성자가 호출되기 전이기에, instant는 null를 가리키고 있다. 따라서 현재 시간이 두 번 출력될 것이라는 기대와는 달리 null이 먼저 출력되고, Sub 생성자가 호출 된 후 현재 시간이 출력된다.  
클래스를 확장해야 할 명확한 이유가 떠오르지 않는다면, 상속을 금지하는 편이 좋다. 상속을 금지하는 방법으로는 두 가지가 있다. 첫 번째로, 클래스를 final로 선언하는 것이다. 두 번째로는 생성자를 private으로 선언하는 것이다. 

## 아이템 20. 추상 클래스보다는 인터페이스를 우선하라
다중 구현 용 타입으로 인터페이스를 추상 클래스보다 우선해야 하는 이유는 크게 3가지로 나타낼 수 있다.
첫 번째, 기존 클래스에 쉽게 확장 할 수 있는 타입은 인터페이스이다. 추상 클래스의 경우 다중 상속이 불가능하기 때문에 기존 클래스가 어떤 클래스를 상속받고 있는 경우, 다른 추상 클래스를 상속받기는 불가능하다. 하지만, 인터페이스의 경우 기존 클래스가 어떤 인터페이스를 구현하고 있다하더라도 다른 인터페이스를 구현할 수 있다. 따라서 추상 클래스, 인터페이스 둘 중 고민한다면 인터페이스로 타입을 정의하는 것이, 구현하는 클래스 입장에서 추후 확장의 폭을 넓혀준다.  
두번 째, 인터페이스는 믹스인 정의에 적합하다. 믹스인이란 믹스인을 구현한 클래스에 본래 타입 외 특정 선택적 행위를 제공한다고 선언하는 효과를 준다. 믹스인의 예로는 Comparable 인터페이스가 있다. 이를 구현한 클래스는 해당 클래스 타입의 인스턴스들 간 순서를 정할 수 있다고 암시할 수 있다. 추상클래스의 경우 믹스인 정의에 적합하지 않은데, 다중 상속이 불가능하기때문이다. 어떤 클래스를 상속받고 있는 클래스는 다른 추상 클래스를 상속받을 수 없기에 클래스 계층구조에 믹스인을 넣을 적합한 위치가 없다.  
세번 째, 인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다. 추상클래스의 경우, 상속하는 클래스는 반드시 추상클래스의 하위 클래스가 되는 계층이 생긴다. 하나의 클래스는 두 추상 클래스를 섬길 수 없지만 인터페이스의 경우 계층으로부터 자유롭기에 가능하다. 따라서 하나의 클래스가 두 개 이상의 인터페이스를 구현하여 기능을 확장해나갈 수 있다. 

## 아이템 22. 인터페이스는 타입을 정의하는 용도로만 사용하라
인터페이스는 타입을 정의하는 용도로만 사용해야한다. 즉, 클라이언트에게 구현 클래스들이 무엇을 할 수 있는 지 알려주는 용도로만 사용해야 한다. 이러한 지침에 맞지 않은 안티 패턴 중 하나가 상수 인터페이스이다. 인터페이스의 필드는 public static final 접근제한자만 가능하다. 무엇을 하는 지를 알려주는 것이 아닌, 필드를 외부에 모두 공개하고 있는 형식이다. 이는 인터페이스 사용자에게 혼란을 줄 수 있으며, 이를 구현한 클래스들의 필드는 상수들로 오염되어 버린다. 따라서 인터페이스 상수는 지양해야 하며, 상수들을 모아둔 클래스가 필요하다면 Enum 또는 인스턴스화 할 수 없는 Util클래스를 만드는 것이 바람직하다. 
