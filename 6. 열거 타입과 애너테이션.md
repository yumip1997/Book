# 열거 타입과 애너테이션
## 아이템 34. int 상수 대신 열거 타입을 사용하라

###  Enum은 타입의 안정성과 표현력을 보장한다.
 int 열거 패턴은 관행적으로 사용되곤 한다. 하지만 int 열거 패턴은 타입의 안정성을 보장할 수 없고 표현력이 좋지 않다는 단점이 있다. 예를 들어 오렌지를 건네야 할 메서드에 사과를 전달하더라고 아무 문제 없이 컴파일 된다. 이는 향후 런타임 오류를 발생시킬 가능성을 높인다. 또한 int 상수가 많아질수록 하나의 상수 클래스가 거대해지고 가독성 역시 떨어지게 된다. 이러한 단점들을 Enum은 해결해준다. Enum은 관련있는 상수들을 모아둔 완전한 형태의 클래스로 타입의 안정성과 표현력 모두를 보장한다. 예를 들어 오렌지를 건네야 할 메서드에 사과 타입의 Enum을 전달하면 컴파일 오류가 발생한다. 따라서 오류를 미리 잡아 해결할 수 있다. 또한 관련있는 상수들의 집합이기에 표현력 역시 좋다. 한 클래스 내에 프로젝트에서 사용하는 모든 상수들을 모아두는 것 보다 관련 있는는 상수들끼리 묶어 각각의 Enum으로 분리해두는 편이 해당 클래스가 어떤 역할을 하는 지 보다 구체적으로 표현할 수 있기 때문이다. 
 
 ### Enum은 맴버변수와 메서드를 지닐 수 있다.
 ```java
 enum DiscountType {  
      
    FIXED("10"){  
        @Override  
        public double calculateDiscountValue(double price, double discountValue) {  
            return price - discountValue;  
        }  
    },  
    RATE("20"){  
        @Override  
        public double calculateDiscountValue(double price, double discountValue) {  
            return price - price * (discountValue/100);  
        }  
    };  
	private final String code;  
    
    DiscountType(String code){  
        this.code = code;  
    }  
      
    public abstract double calculateDiscountValue(double price, double discountValue);  
    
    public static DiscountType find(String code){  
        return Arrays.stream(DiscountType.values())  
                .filter(e -> e.code.equals(code))  
                .findFirst()  
                .orElseThrow(() -> new RuntimeException("DiscountType not found"));  
  }  
}
 ```
 각 상수들을  DiscountType형의 인스턴스를 지니고 있다. 다시말해, 각 인스턴스는 생성자에 의해 초기화된 맴버변수와 DiscountType의 메서드들을 가지고 있는 것이다. 
 
 ### 상수별 메서드 구현으로 다형성을 극대화할 수 있다.
 상수마다 동작이 달라져야 하는 메서드가 필요할 경우가 있다. 이 경우 열거 타입에 추상 메서드를 선언하고 각 상수별로 재정의하면 된다. 결과적으로 Enum을 사용하면 다형성의 원리를 이용하여 상황에 맞게 목적을 달성할 수 있다. 예를 들어, 할인정책 별 할인된 가격을 계산하는 방식은 다르다. 구체적으로, 정액 할인인지 정률 할인인지에 따라 할인된 가격을 계산하는 방식은 다르다. 

 
## 아이템 35. ordinal 메서드 대신 인스턴스 필드를 사용하라
 Enum은 Enum의 상수가 몇 번째 위치에 있는지를 반환하는 ordinal 메서드를 제공한다. ordinal 메서드를 사용하는 일은 거의 없어야 한다. 그 대신 상수의 위치를 나타내고자 한다면 인스턴스 필드를 사용하는 것이 바람직하다.
 ```java
enum Coin {  
    NICKEL,  
    DIME,
    public int getValue(){  
        return (ordinal() + 1) * 5  
}
 ```
 위의 Ensemble 열거 타입에는 Coin의 값을 나타내는 getValue 메서드를 ordinal 메서드를 사용하였는데, 이는 매우 바람직하지 못한 코드이다. 만약 1 Cent를 표현하기 위해 Cent라는 상수를 추가할 경우 getValue 메서드를 수정해야 한다. 또한 25Cent를 표현하기 위해, QUARTER라는 상수를 추가하려면 DIME과 QUARTER사이 dummy 상수를 추가해야 한다. 따라서 ordinal 메서드를 사용하지 말고 인스턴스 필드로 확장 가능성을 높여야 한다.
 ```java
enum Coin {  
    PENNY(1),  
    NICKEL(5),  
    DIME(10),  
    QUARTER(25);  
    
    Coin(int value) {  
        this.value = value;  
    }  
  
    private final int value;  
}
```

## 아이템 36. 비트 필드 대신 EnumSet을 사용하라
## 아이템 37. ordinal 인덱싱 대신 EnumMap을 사용하라
Enum의 맴버 별로 특정 데이터 군을 그룹화해야할 경우, ordinal 인덱싱을 사용하는 것보다 EnumMap을 사용하는 것이 바람직하다. 불필요한 형변환이 없고 런타임 에러를 방지할 수 있기 때문이다. 

Worker들의 집합을 Career별로 그룹핑하여 나타내야할 경우가 있을 것이다.
```java
    enum Career {
        PLANNER,
        DEVELOPER,
        TESTER;
    }

    class Worker {
        private String name;
        private Career career;

        public Worker(String name, Career career){
            this.name = name;
            this.career = career;
        }
    }

```
ordianl 인덱싱을 사용하여 배열의 0번째 요소에는 PLANNER인 Worker들, 1번째 요소에는 DEVELOPER인 WOKER들, 2번째 요소에는 TESTER인 Worker들을 가리키도록 할 수 있다.
```java
    List<Worker>[] workerArr= (List<Worker>[]) new List[Career.values().length];
    for (int i=0;i<Career.values().length;i++){
        workerArr[i] = new ArrayList<>();
    }

    for (Worker worker : workerList) {
        workerArr[worker.career.ordinal()].add(worker);
    }
```
하지만 이런 식으로 로직을 구성했을 경우 형변환인 필수적이고, 배열의 길이를 Career의 values의 길이만큼 설정하지 않았다면 ArrayIndexOutOfBoundsExceoption 예외가 발생할 수 있다.

EnumMap을 활용하면 형변환이 필요없고 런타임 에러를 방지하면서 Key는 Career 타입으로 Value는 List<Worket> 타입으로 하는 map을 만들 수 있을 것이다.
```java
        Map<Career, List<Worker>> map = new EnumMap<>(Career.class);

        for (Career career : Career.values()) {
            map.put(career, new ArrayList<>());
        }

        for (Worker worker : workerList) {
            map.get(worker.career).add(worker);
        }
```

EnumMap 역시 내부적으로 배열을 사용하고 있기에 ordinal을 쓴 배열과 성능이 비견된다. 또한 Enum의 맴버 length만큼 배열의 길이를 정하기 때문에 안전하게 동작한다. 
```java
    public EnumMap(Class<K> keyType) {
        this.keyType = keyType;
        keyUniverse = getKeyUniverse(keyType);
        vals = new Object[keyUniverse.length];
    }
```

## 아이템 38.  확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라
열거 타입 자체는 확장할 수 없지만 인터페이스를 이용하여 인터페이스를 확장할 수 있다. 열거 타입 자체를 구현하거나 상속할 수 없지만, 열거 타입은 인터페이스를 구현할 수 있기 때문이다. 
## 아이템 39. 명명 패턴보다 애너테이션을 사용하라
## 아이템 40. @Override 애너테이션을 일관되게 사용하라
## 아이템 41. 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라
