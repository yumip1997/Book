
# 람다와 스트림
## 아이템 42. 익명 클래스보다는 람다식를 사용하라
람다식은 단 하나의 추상 메서드를 가지는 인터페이스의 인스턴스 생성을 표현하는 방식이다. 즉, 람다식의 평가결과 인스턴스가 생성된다. 람다식을 사용하면 간결하게 인스턴스를 생성하는 코드를 작성할 수 있다. 
다음은 람다식을 사용한 예시이다. 아이템 34에서는 상수별 몸체에 apply를 각각 구현했지만, 인스턴스 필드에 함수형 인터페이스를 선언함으로 더욱 가독성 있게 코드를 작성할 수 있다. DoubleBinaryOperator는 java.util.function 패키지가 제공하는 함수형인터페이스 중 하나로, 
```java
double applyAsDouble(double left, double right);
```
applyAsDouble 메서드 하나만을 가지고 있다. 각 필드는 람다식으로 DoubleBinaryOperator 타입의 인스턴스를 생성하는 코드를 나타내고 있다. BasicOperation의 apply는 각 필드의 람다식의 평가 결과 생성된 인스턴스의 단 하나 뿐인 메서드인 applyAsDouble의 실행 결과를 return 한다. 
```java
    enum BasicOperation implements Operation{
        PLUS("+", (x,y) -> x+y),
        MINUS("-", (x,y) -> x-y),
        TIMES("*", (x,y) -> x*y),
        DIVIDE("/", (x,y) -> x/y);

        private String symbol;
        private DoubleBinaryOperator operator;

        BasicOperation(String symbol, DoubleBinaryOperator operator){
            this.symbol = symbol;
            this.operator = operator;
        }
        
        @Override
        public double apply(double x, double y) {
            return operator.applyAsDouble(x,y);
        }
    }
```

한편, 함수형 인터페이스는 단 하나의 추상 메서드만을 지니기에 람다식과 함수형 인터페이스는 밀접한 관계가 있다. 람다식으로 함수형 인터페이스의 인스턴스를 생성하는 코드를 가독성있게 작성할 수 있기 때문이다. 
익명 클래스를 통해서도 인스턴스를 만들 수 있지만, 람다식보다 코드가 길기에 함수형 인터페이스의 인스턴스 생성 코드를 작성할 때, 람다식으로 표현하는 것이 적합하다. 

람다식 보다 익명 클래스를 사용해야하는 경우가 있다. 먼저 추상 클래스의 인스턴스를 만들 때이다. 람다는 인터페이스의 인스턴스만을 생성할 수 있기때문이다. 또한 여러 개의 메서드의 지니는 인터페이스의 인스턴스를 만들 때에도 익명 클래스를 이용해야 한다. 람다식에서의 this는 바깥 인스턴스를 가리키고, 익명 클래스의 this는 익명 클래스의 인스턴스 자신을 가리킨다. 따라서 this로 자기 자신을 표현하고 싶을 때는 익명 클래스를 사용해야한다. 

## 아이템 43. 람다보다는 메서드 참조를 사용하라
익명클래스보다 람다를 사용하는 가장 큰 이유는 간결함이다. 람다보다 더 간결한 표현이 있는데, 그것이 바로 메서드 참조이다. 다음은 람다식으로 더하기 기능 메서드를 가지고 있는 인스턴스 생성을 표현한 방식이다.
```java
  DoubleBinaryOperator plusOperator = (a,b) -> a+b;
```

Double 클래스의 정적 메서드인 sum을 이용하면 이보다 더 명확하고 간결하게 나타낼 수 있다.
```java
  DoubleBinaryOperator plusOperator = Double::sum;
```
메서드 참조가 람다보다 좋은 점은 간결하고 명확하다는 점이다. 먼저 코드가 더 짧고 메서드 이름을 통해 어떤 기능을 하는지 명확히 알 수 있다. 또한 메서드에 대한 설명은 잘 쓰여진 문서로부터 알 수 있다.  
하지만, 람다가 메서드 참조보다 더 간결할 경우에는 람다를 쓰는 것이 바람직하다.
```java
  service.excute(SomethingRunner::run)
  service.excute(() -> run())
```

## 아이템 44. 표준 함수형 인터페이스를 사용하라
커스텀한 함수형 인터페이스를 만들기 전에 표준 함수형 인터페이스를 사용하여 원하는 로직을 처리할 수 있는 지를 먼저 고민해야한다. API가 다루는 개념의 수가 줄어 향후 유지보수 관점에서 편리하고, 표준 함수형 인터페이스가 제공하는 유용한 디폴트 메서드를 재사용할 수 있기때문이다. java.util.function 패키지에는 유용한 함수형 인터페이스들이 정의되어 있다. 자주 사용되는 표준 함수형 인터페이스는 다음과 같다.   
- Function<T, R> : R apply(T t)
- Predicate<T> : boolean test(T t)
- Supplier<T> : T get()
- Consumer<T> : void accept(T t)
- UnaryOperator<T> : T apply(T t)
- BinaryOperator<T> : T apply(T t1, T t2)   
 
한편, 표준 함수형 인터페이스로 대체할 수도 있지만, 자바에는 Comparator와 같은 인터페이스들이 여전히 자리잡고 있다. Comparator 인터페이스는 단 하나의 추상 메서드만을 가지고 있으며 이는 두 개의 인자를 받아 int형의 값을 반환한다. 따라서 표준 함수형 인터페이스 ToIntBiFunction의 applyAsInt 메서드와 구조적으로 동일하다. 하지만, Comparator 인터페이스는 이름 자체만으로 해당 인터페이스가 어떤 역할을 맡고 있는지를 보여준다. 그리고 구현하는 쪽에서 지켜야할 규약들이 문서로 잘 설명되어 있다. 이에 더해, 비교자들을 변환하고 조합해주는 유용한 디폴트 메서드들을 지니고 있다.  
만약 표준 함수형 인터페이스로는 요구 로직을 처리할 수 있어 직접 함수형 인터페이스를 정의해야한다면, @FunctionInterface 애너테이션을 붙이는 습관을 들이는 것이 좋다. 해당 애너테이션은 인터페이스가 람다용으로 설계된 것임을 알려주는 가장 바람직한 수단이다. 그리고 오직 하나의 추상메서드만을 지니고 있는 인터페이스라는 사실도 시사한다. 더 나아가, 누군가 실수로 추상메서드를 추가한다면 컴파일러가 해당 오류를 잡아줄것이다.

