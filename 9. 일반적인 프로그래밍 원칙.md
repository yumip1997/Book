
# 일반적인 프로그래밍 원칙
## 아이템 57. 지역변수의 범위를 최소화하라

- 지역변수는 가장 처음 쓰일 때 선언하기
  - 코드 블록이 시작할 때 지역변수들을 미리 선언해두는 방식은 바람직 하지 않다. 미리 선언해두면 가독성이 떨어지고 언제 해당 지역변수가 사용되는지 불명확하기 때문이다.
  
  ```java
  //바림직하지 않은 예
  int start = 0;
  int end = 0;
  int mid = 0;
  
  //start로 무엇인가를 함
  //end로 무엇인가를 함
  //mid로 무엇인가를 함
  
  //바람직한 예
  int start = 0;
  //start로 무엇인가를 함
  
  int end = 0;
  //end로 무엇인가를 함
  
  int mid = 0;
  //mid로 무엇인가를 함
  ```
  
  
  
- 지역변수는 선언과 동시에 초기화 해두기
  - 초기화에 필요한 정보가 주어지지 않는다면 그 정보가 주어질 때까지 선언을미루어 두는 편이 미리 선언해두는 것보다 좋다.
  - try-catch 문에서는 예외 
    - 선언한 지역 변수가 예외를 던질 가능성이 있다면 try 블록 안에서 초기화 해야한다. 하지만 이 경우에도 try 블록 앞에 변수를 선언해야한다. 
  
- 메서드를 작게 만들고 한 가지 기능에 집중하도록 하기

## 아이템 58. 전통적인 for문 보다는 for-each문을 사용하라

- 전통적 for문

  ```java
  //배열 순회
  for(int i=0;i<a.length;i++) {
      ... //a[i]로 어떤 일은 함
  }
  ```

  - 반복자와 인덱스 변수는 코드를 지저분한다.
  - 순회 대상이 배열이냐 컬렉션이냐에 따라 코드 형태가 달라진다.
    - ex. a가 배열을 가리킬 경우 크기를 알기 위해 a.length를 이용해야 하는데 리스트일 경우 a.size()를 이용해야 함 -> 순회하는 기능은 같은데 코드 형태가 대상의 타입에 따라 각각 다름

- for-each문

  - ```
    for(Element e : elements){
    
    }
    ```

  - 반복자와 인덱스 변수를 사용하지 않아 코드가 깔끔해진다.

  - 순회 대상이 배열이든 컬렉션이든 형태는 동일하다. 

  - 중첩된 반복문을 이용할 때의 실수 예방

    - ```java
      enum Face { ONE, TWO, THREE, FOUR, FIVE, SIX}
      
              Collection<Face> faces = EnumSet.allOf(Face.class);
              for(Iterator<Face> i = faces.iterator(); i.hasNext(); ){
                  for(Iterator<Face> j = faces.iterator(); j.hasNext(); ){
                      System.out.println(i.next() + " " + j.next());
                  }
      ```

      - 중첩된 for문으로, 바깥 컬렉션의 i.next() 하나 당 안쪽 컬렉션의 j.next()가 진행되어 총 36번 반복 될 것 같지만 안쪽컬렉션에서 j.next()만큼 i.next()가 진행되어 6번 밖에 반복되지 않는다.
      - 이렇게 중첩된 for문으로 반복을 진행할 경우, 만약 바깥 컬렉션의 크기가 안쪽 컬렉션의 크기보다 작다면 NoSuchElementException이 던져진다. 크기가 동일하거나 더 크다고 해도 의도한 결과가 도출되지 않는다.

    - ```java
      enum Face { ONE, TWO, THREE, FOUR, FIVE, SIX}
      
              for(Face face1 : faces){
                  for(Face face2 : faces){
                      System.out.println(face1.name() + " " + face2.name());
                  }
              }
      
      ```

      - 중첩된 for문을 사용할 때보다 코드가 더 깔끔해지고 반복은 의도한대로 총 36번 진행된다. 바깥 컬렉션의 크기와 안쪽 컬렉션의 크기와 상관없이 의도한 결과가 도출될 것이다.

- for-each문을 피해야하는 경우

  - 파괴적인 필터링 
    - 컬렉션을 순회하면서 선택된 원소를 제거해야하는 경우 반복자의 remove 메서드를 호출해야한다.
  - 변형 
    - 인덱스를 통해 원소 값을 변경한다. 
  - 병렬 반복
    - 여러 컬렉션을 병렬로 순회할 경우, 각각의 반복자와 인덱스 변수를 사용해야한다.

##  아이템 59. 라이브러리를 익히고 사용하라

## 아이템 60. 정확한 답이 필요하다면 float와 double은 피하라

- float, double은 넓은 범위의 수를 정밀한 '근사치'로 계산하도록 설계되어있다. 따라서 금융과 같이 정확한 답이 필요할 경우 사용하지 말아야 한다.

- 정확한 답이 필요한 경우, BigDecimal, int, long을 사용해야 한다.

  - BigDecimal은 정확하지만, 기본타입보다 느리다. 

  - 따라서 열여덟자리를 넘어가는 수의 경우 BigDecimal 사용이 적절하지만, 성능이 중요하고 열여덟자리를 넘어가지 않는 수의 경우는 int,long 사용이 적절하다.

## 아이템 61. 박싱된 기본타입보다는 기본 타입을 사용하라
- 자바에는 기본타입에 대응하는 참조 타입 즉 박싱된 기본 타입이 각각 하나씩 있다.
  - 기본타입 : int, long, double, boolean
  - 박싱된 기본타입 : Integer, Long, Double, Boolean
- 기본타입과 박싱된 기본타입의 차이점
  - 기본타입은 값만 가지고 있는데, 박싱된 기본타입은 값도 가지고 식별성이란 속성도 지니고 있다. 따라서 박싱된 기본타입에서는 두 인스턴스의 값이 같아도 서로 다르다고 식별될 수 있다.

    ```java
    Integer i = new Integer(42);
    Integer j = new Integer(42);
    
    System.out.println(i == j);	//false 출력
    ```

  - 기본타입의 값은 언제나 유효하지만 박싱된 기본타입은 null 값을 가질 수 있다.

  - 기본타입이 박싱된 기본타입보다 시간, 메모리 측면에서 효율적이다.

- 박싱된 기본타입을 사용했을 때의 단점
  - 박싱된 기본타입에 == 연산을 사용하면 오류가 일어날 가능성이 있다.
    - 기본타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다. 박싱된 기본타입은 유효하지 않은 값 즉 null 값을 지니는데, 이 경우 박싱이 풀려버리면 NullPointerException이 발생한다. 
  - 기본 타입을 박싱하는 과정에서 새로운 객체가 생성되기에 속도, 메모리 측면에서 비효율적이다.

- 박싱된 기본타입을 사용해야 하는 경우
  - 컬렉션을 사용할 때 - 컬렉션은 기본타입을 담을 수 없기에 박싱된 기본타입을 써야한다.
  - 리플렉션을 통해 메서드를 호출할 때

## 아이템 61. 다른 타입이 적절하다면 문자열 사용은 피하라

- 문자열은 열거 타입을 대신하기에 부적합
  - 상수를 열거할 경우, 열거 타입이 문자열보다 월등히 더 낫다.
- 문자열은 혼합 타입을 대신하기에 부적합
  - 혼합 요소의 각 요소에 접근하기 위해선 파싱을 해야하는 데 이는 느리다.

## 아이템 63. 문자열 연결은 느리니 주의하라

- 문자열 연결 연산자로 문자열 n개를 잇는 시간은 n^2에 비례한다.
- 문자열 연결 연산자(+)를 사용하는 것보다 StringBuilder의 append 메서드를 사용하는 편이 속도, 메모리 측면에서 더 좋다.

## 아이템 64. 객체는 인터페이스를 사용해 첨조하라

- 적합한 인터페이스가 있다면 매개변수 뿐아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하는 것이 유연성, 확장성 측면에서 좋다.

  - ```java
    HashSet<String> hashset = new HashSet<>();
    
    ... //hashset으로 어떤일을 함
    ```

    - 로직을 만들다 순회 순서를 보장하는 LinkedHashSet으로 바꾸고 싶은 경우 관련된 모든 코드를 수정해야 한다.

  - ```java
    Set<String> set = new HashSet<>();
    ...// set으로 어떤일은 함
    ```

    - LinkedHashSet으로 바꾸고 싶은 경우 구현 타입만 바꾸어 주면 된다.

- String,  BigInteger 같이 적합한 인터페이스가 없거나, 인터페이스에는 없는 특별한 메서드를 사용해야 한다면 특정 클래스를 구현 타입으로 두는 것이 맞다. 하지만 이 경우에도 클래스의 계층구조 중 필요한 기능을 만족하는 가장 상위의 클래스 타입을 사용해야 유연성, 확장성 측면에서 적절하다.

## 아이템 65. 리플렉션보다는 인터페이스를 사용하라

- 리플렉션 기능을 통해 Class 객체의 생성자, 메서드, 필드에 접근해 조작할 수 있다. 즉, 해당 클래스의 인스턴스를 생성하거나, 메서드를 호출하거나 필드를 변경할 수도 있다는 것이다.
- 리플렉션 기능의 단점
  - 컴파일타임 타입 검사가 주는 이점을 누릴 수 없다.
    - 리플렉션을 이용해 메서드를 호출할 경우, 해당 메서드가 존재하지 않을 때 런타임 오류가 발생한다.  이로인해, 프로그램이 시작되기 전 컴파일타임에서 메서드의 존재유무를 검사해 미리 오류를 발견할 수 없는 것이다. 
  - 코드가 지저분해지고, 성능도 떨어진다.


## 아이템 66. 네이티브 메서드는 신중히 사용하라

- 네이티브 메서드는 C, C++ 같은 네이티브 프로그래밍 언어로 작성한 메서드를 뜻한다. 네이티브 라이브러리를 사용해야 할 경우 네이티브 메서드를 사용해야 하지만 이 경우 이외에는 지양해야한다. 먼저, 가비지 컬렉터가 네이티브 메모리를 자동 회수하지 못한다. 그리고 자바 코드와 네이티브 경계를 넘어들때마다 비용이 추가된다. 더 나아가 네이티브 메서드와 자바 코드 사이 접착 코드를 작성해야 하는데, 이는 복잡하고 가독성 또한 떨어뜨린다. 따라서 네이트 메서드 사용은 신중해야 한다.

## 아이템 67. 최적화는 신중히 사용하라
## 아이템 68. 일반적으로 통용되는 명명규칙을 따르라

- 패키지
  - 패기지와 모듈 이름은 각 요소를 점(.)으로 구분하고 모든 요소들은 소문자로 이루어진다.
  - 외부에서도 사용될 경우, 인터넷 도메인 이름의 역순을 사용한다.
    - ex. com.google
  - 패키지 이름의 나머지 이름은 해당 패키지를 설명하는 하나 이사으이 요소로 이루어진다.
    - java.util은 java.util.concurrent.atomic와 같이 java.util 하위에 수많은 패키지를 가지고 있다.
- 클래스
  - 대문자로 시작
  - 단수 명사, 명사구
  - 줄임말은 쓰지 말아햐한다.
- 인터페이스
  - 대문자로 시작
  - 클래스 이름과 대응되게 짓거나 able, ible로 끝나는 형용사로 지어야한다.
  - 줄임말은 쓰지 말아햐한다.
- 메서드
  - 소문자로 시작
  - 인스턴스의 속성을 반환하는 메서드의 이름은 명사, 명사구, get으로 시작하는 동사구로 지어야한다.
    - ex. size, hasCode, getTime
  - 객체의 타입을 바꾸어 다른 타입의 또 다른 객체를 반환하는 메서드의 이름은 toType 형태로 짓는다.
    - ex. toString, toArray
  - 객체의 값을 기본 타입의 값으로 반환하는 메서드의 이름은 typeValue로 짓는다.
    - ex.intValue
  - boolean을 반환하는 메서드는 is로 시작 (드물게 has로 시작)
- 필드
  - 소문자로 시작
  - 상수 필드는 모두 대문자로 쓰이고 밑줄로 구분한다. 
    - ex. NEGATIVE_INFINITY
- 지역변수
  - 약어 가능
- 타입 변수
  - 한 문자로 표현
    - 임의의 타입 : T
    - 컬렉션 원소의 타입 : E 
    - 맴의 키와 값 : K,V
    - 예외 : X
    - 메서드의 반환타입 : R
