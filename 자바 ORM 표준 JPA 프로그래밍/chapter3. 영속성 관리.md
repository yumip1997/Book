## Chapter3. 영속성 관리
### 영속성 컨텍스트
- 의미 : 엔티티를 영구 저장하는 환경

### 엔티티의 생명주기
EntityManger가 엔티티의 생명주기를 관리할 수 있다. 영속 컨텍스트에 저장하거나 삭제할 수 있다. 
- 비영속 : 영속성 컨텍스트와 관계가 없는 상태
    - ex. 순수 자바 객체
- 영속 : 엔티티가 영속성 컨텍스트에 저장된 상태 -> 영속성 컨텍스트가 관리하는 상태
    ```java
    void persist(Object var1);
    ```
- 준영속 : 엔티티가 영속성 컨텍스트에 저장되었다가 분리된 상태
    ```java
    // 파라미터로 받은 엔티티가 준영속 상태가 됨
    void detach(Object var1);

    //영속성 컨텍스트가 관리하던 엔티티가 준영속 상태가 됨
    void close();
    void clear();
    ```
- 삭제 : 엔티티가 영속성 컨텍스트로부터 제거된 상태 -> 쓰기 지연 저장소에 해당 엔티티에 대한 delete 쿼리가 저장되며 트랜잭션 커밋 시 delete 쿼리가 데이터베이스에 전달된다.
    ```java
    void remove(Object var1);
    ```

### 영속성 컨텍스트의 특징
<b>1. 1차 캐시</b>  
영속성 컨텍스트는 내부에 캐시 저장소를 지니고 있다. Map 자료구조이며 key는 엔티티의 @Id로 매핑한 값이며 Value는 엔티티의 인스턴스주소이다.
- Map의 자료구조
    - key : 엔티티의 @Id로 매핑한 값
    - value : 엔티티의 인스턴스 주소
- 조회시 일어나는 과정
     ```java
    // 첫 번째 파라미터 : 엔티티의 클래스 타입
    // 두 번쨰 파라미터 : 식별자 값 (@Id에 매핑되는 멤버변수의 값)
    <T> T find(Class<T> var1, Object var2);
    ```
  1차 캐시 저장소 존재여부 확인
    - o -> 엔티티 인스턴스를 반환
    - x -> DB 조회 후 데이터 존재 시, 엔티티를 생성하여 캐시 저장소에 저장한 후 해당 앤티티 인스턴스(영속)를 반환  

<b>2. 영속 엔티티의 동일성 보장</b>
   ```java
   Member m1 = em.find(Member.class, "id1");
   Member m2 = em.find(Member.class, "id1");

   assertEquals(m1, m2); // true
   ```
   데이터 조회 시, 1차 캐시 저장소에 존재하는 인스턴스를 반환한다. key가 동일하다면 같은 인스턴스를 반환하기에 동일성이 보장된다.  

<b>3. 쓰기 지연</b>
- 쓰기 지연 SQL 저장소 : 영속성 컨텍스트 내부에는 쓰기 작업 SQL들이 해당 저장소에 존재
- 쓰기 지연
    - 실제 트랜잭션 커밋이 일어나기 전까지, 쓰기 작업이 지연된다. (즉, CUD 관련 로직이 호출되는 때마다 관련 쿼리가 데이터베이스에 전달되지 않고, 한번에 모아서 전달된다.)
    - 트랜잭션 커밋이 일어날 때, 엔티티 매니저가 영속성 컨텍스트를 플러시한다. 즉, 쓰기 지연 SQL 저장소에 저장된 CUD 관련 쿼리를 데이터베이스에 전달한다. 그리고 나서 실제 트랜잭션은 커밋된다.  

<b>4. 변경감지</b>  
엔티티가 영속성 컨텍스트의 1차 캐시 저장소에 저장될 때, 
최초 엔티티의 복사본도 저장되는데 이를 스냅샷이라고 한다.
스냅샷과 엔티티를 비교하여 변경감지를 수행할 수 있으며, 그 과정은 다음과 같다.  
- 트랜잭션 커밋 시, flush 호출(by 엔티티 매니저)
- 1차 캐시 저장소에 존재하는 엔티티와 스냅샷을 비교
- 변경된 엔티티가 있다면 수정쿼리가 쓰기 지연 SQL 저장소에 저장된다.
- 쓰기 지연 SQL 저장소의 쿼리들이 데이터베이스에 전달
- 트랜잭션 커밋  

### 플러시(flsuh)
- 의미 : 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영
- 호출 시
    1) 변경감지 동작 -> 스냅샷과 엔티티 비교 후 변경된 엔티티가 있으면 수정쿼리가 쓰기 지연 SQL 저장소에 저장
    2) 쓰기 지연 SQL 저장소에 저장된 쿼리들을 데이터베이스에 전달한다.
- 호출 방법
    1) 엔티티 매니저의 flush 메서드 직접호출
    2) 트랜잭션 커밋 전 자동 호출
    3) JPQL 쿼리 실행 시 호출  
    <aside>💡 엔티티 매니저의 find 호출 시에는 플러시가 자동 호출되지 않는다.</aside>
- 플러시 모드 옵션
    - FlushModeType.AUTO : 트랜잭션 커밋 전이나 JPQL 쿼리 실행 시 자동 호출
    - FlushModeType.COMMIT : 트랜잭션 커밋 전 자동 호출
    ```java
        em.setFlushMode(FlushModeType.COMMIT)
    ```

### 준영속
- 의미 : 영속성 컨텍스트에서 관리되던 엔티티가 영속성 컨텍스트에서 분리됨 -> 영속성 컨텍스트가 제공하는 기능(1차 캐시, 쓰기 지연, 변경 감지 등) 사용 불가
- 방법
    1) detach : 파라미터로 받은 엔티티만 준영속 상태로 전환
    ```java
    void detach(Object var1);
    ```
    2) clear : 모든 엔티티를 준영속 상태로 만듦 -> 1차 캐시 저장소, 쓰기 지연 SQL 저장소가 초기화 됨
    ```java
    void clear();
    ```
    3) close
    ```java
    void close();
    ```
- 병합 : 준영속 상태의 엔티티를 다시 영속 상태로 변경 후 영속 상태의 엔티티 반환
    ```java
    <T> T merge(T var1);
    ```



