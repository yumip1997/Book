## Chapter3. 영속성 관리
### 영속성 컨텍스트
- 의미 : 엔티티를 영구 저장하는 환경

### 엔티티의 생명주기
EntityManger가 엔티티의 생명주기를 관리할 수 있다. 영속 컨텍스트에 저장하거나 삭제할 수 있다. 
- 비영속 : 영속성 컨텍스트와 관계가 없는 상태
    - ex. 순수 자바 객체
- 영속 : 엔티티가 영속성 컨텍스트에 저장된 상태 -> 영속성 컨텍스트가 관리하는 상태
    ```java
    void persist(Object var1);
    ```
- 준영속 : 엔티티가 영속성 컨텍스트에 저장되었다가 분리된 상태
    ```java
    void detach(Object var1);

    //영속성 컨텍스트가 관리하던 엔티티가 준영속 상태가 됨
    void close();
    void remove();
    ```
- 삭제 : 엔티티가 영속성 컨텍스트로부터 제거된 상태
    ```java
    void remove(Object var1);
    ```

### 영속성 컨텍스트의 특징
### 1차 캐시  
---
영속성 컨텍스트는 내부에 캐시 저장소를 지니고 있다. Map 자료구조이며 key는 엔티티의 @Id로 매핑한 값이며 Value는 엔티티의 인스턴스주소이다.
- Map의 자료구조
    - key : 엔티티의 @Id로 매핑한 값
    - value : 엔티티의 인스턴스 주소
- 조회시 일어나는 과정
     ```java
    // 첫 번째 파라미터 : 엔티티의 클래스 타입
    // 두 번쨰 파라미터 : 식별자 값 (@Id에 매핑되는 멤버변수의 값)
    <T> T find(Class<T> var1, Object var2);
    ```
  1차 캐시 저장소 존재여부 확인
    - o -> 엔티티 인스턴스를 반환
    - x -> DB 조회 후 데이터 존재 시, 엔티티를 생성하여 캐시 저장소에 저장한 후 해당 앤타타 인스턴스(영속)를 반환  
### 영속 엔티티의 동일성 보장
---
   ```java
   Member m1 = em.find(Member.class, "id1");
   Member m2 = em.find(Member.class, "id1");

   assertEquals(m1, m2); // true
   ```
   데이터 조회 시, 1차 캐시 저장소에 존재하는 인스턴스를 반환한다. key가 동일하다면 같은 인스턴스를 반환하기에 동일성이 보장된다.
### 쓰기 지연
---
- 쓰기 지연 SQL 저장소 : 영속성 컨텍스트 내부에는 쓰기 작업 SQL들이 해당 저장소에 존재
- 쓰기 지연
    - 실제 트랜잭션 커밋이 일어나기 전까지, 쓰기 작업이 지연된다. (즉, CUD 관련 로직이 호출되는 때마다 관련 쿼리가 데이터베이스에 전달되지 않고, 한번에 모아서 전달된다.)
    - 트랜잭션 커밋이 일어날 때, 엔티티 매니저가 영속성 컨텍스트를 플러시한다. 즉, 쓰기 지연 SQL 저장소에 저장된 CUD 관련 쿼리를 데이터베이스에 전달한다. 그리고 나서 실제 트랜잭션은 커밋된다.
### 변경감지
---
엔티티가 영속성 컨텍스트의 1차 캐시 저장소에 저장될 때, 
최초 엔티티의 복사본이 존재하고 이를 스냅샷이라고 한다.
스냅샷과 엔티티를 비교하여 변경감지를 수행할 수 있는 데, 그 과정은 다음과 같다.  
- 트랜잭션 커밋 시, flush 호출(by 엔티티 매니저)
- 1차 캐시 저장소에 존재하는 엔티티와 스냅샷을 비교
- 변경된 엔티티가 있다면 수정쿼리가 쓰기 지연 SQL 저장소에 저장된다.
- 쓰기 지연 SQL 저장소의 쿼리들이 데이터베이스에 전달
- 트랜잭션 커밋

